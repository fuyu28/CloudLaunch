/**
 * @fileoverview メモ同期サービス
 *
 * メモのクラウド同期に関するビジネスロジックを提供します。
 * - ローカル←→クラウド間の双方向同期
 * - タイムスタンプベースの競合解決
 * - ハッシュベースの内容比較
 * - 処理済みメモの重複防止
 */

import { createHash } from "crypto"

import type { MemoSyncResult, CloudMemoInfo } from "../../types/memo"
import { prisma } from "../db"
import { uploadObject, downloadObject } from "./cloudStorageService"
import { CloudPathManager } from "../utils/cloudPathManager"
import { logger } from "../utils/logger"
import { memoFileManager } from "../utils/memoFileManager"
import type { S3Client } from "@aws-sdk/client-s3"

/**
 * メモ内容のSHA256ハッシュを計算します
 */
export function calculateContentHash(content: string): string {
  return createHash("sha256").update(content.trim(), "utf8").digest("hex")
}

/**
 * クラウドメモファイルから実際のメモ内容を抽出します
 */
export function extractMemoContent(fileContent: string): string {
  const lines = fileContent.split("\n")
  let actualContent = ""
  let foundContentStart = false

  for (const line of lines) {
    if (line.startsWith("#") && !foundContentStart) {
      continue // タイトル行をスキップ
    }
    if (line.startsWith("<!--") || line.startsWith("-->")) {
      continue // コメント行をスキップ
    }
    if (line.trim() === "" && !foundContentStart) {
      continue // 内容開始前の空行をスキップ
    }
    foundContentStart = true
    actualContent += line + "\n"
  }

  return actualContent.trim()
}

/**
 * メモファイル内容を生成します
 */
export function generateMemoFileContent(title: string, content: string, gameTitle: string): string {
  const timestamp = new Date().toISOString()
  return `# ${title}

<!-- Created: ${timestamp} -->
<!-- Generated by CloudLaunch -->
<!-- Game: ${gameTitle} -->

${content}
`
}

/**
 * ローカルメモをクラウドにアップロードします
 */
export async function uploadLocalMemo(
  s3Client: S3Client,
  bucketName: string,
  localMemo: { id: string; title: string; content: string; game: { title: string } },
  existingCloudMemo?: CloudMemoInfo
): Promise<{
  action: "uploaded" | "cloudOverwritten" | "skipped"
  message: string
}> {
  const s3Key = CloudPathManager.buildMemoPath(localMemo.game.title, localMemo.title, localMemo.id)

  if (!existingCloudMemo) {
    // 新規アップロード
    const fileContent = generateMemoFileContent(
      localMemo.title,
      localMemo.content,
      localMemo.game.title
    )

    await uploadObject(s3Client, bucketName, s3Key, fileContent, "text/markdown")
    return { action: "uploaded", message: `アップロード: ${localMemo.title}` }
  }

  // 既存メモの場合、詳細データを取得
  const localMemoData = await prisma.memo.findUnique({
    where: { id: localMemo.id }
  })

  if (!localMemoData) {
    return {
      action: "skipped",
      message: `ローカルメモが見つからないためスキップ: ${localMemo.title}`
    }
  }

  if (localMemoData.updatedAt > existingCloudMemo.lastModified) {
    // ローカルの方が新しい場合、内容比較してからクラウドを更新
    const cloudContent = await downloadCloudMemoContent(s3Client, bucketName, existingCloudMemo.key)

    if (cloudContent) {
      const cloudActualContent = extractMemoContent(cloudContent)
      const localContentHash = calculateContentHash(localMemoData.content)
      const cloudContentHash = calculateContentHash(cloudActualContent)

      if (localContentHash === cloudContentHash) {
        return { action: "skipped", message: `スキップ: ${localMemo.title} (内容が同じ)` }
      }
    }

    // 内容が異なる場合はクラウドを更新
    const fileContent = generateMemoFileContent(
      localMemo.title,
      localMemo.content,
      localMemo.game.title
    )

    await uploadObject(s3Client, bucketName, s3Key, fileContent, "text/markdown")
    return {
      action: "cloudOverwritten",
      message: `クラウド更新: ${localMemo.title} (ローカル版が新しい)`
    }
  } else if (existingCloudMemo.lastModified > localMemoData.updatedAt) {
    // クラウドの方が新しい場合は、ダウンロード処理で処理
    return {
      action: "skipped",
      message: `ダウンロード処理待ち: ${localMemo.title} (クラウド版が新しい)`
    }
  } else {
    // タイムスタンプが同じ場合、ハッシュで内容比較
    const cloudContent = await downloadCloudMemoContent(s3Client, bucketName, existingCloudMemo.key)

    if (cloudContent) {
      const cloudActualContent = extractMemoContent(cloudContent)
      const localContentHash = calculateContentHash(localMemoData.content)
      const cloudContentHash = calculateContentHash(cloudActualContent)

      if (localContentHash === cloudContentHash) {
        return { action: "skipped", message: `スキップ: ${localMemo.title} (内容が同じ)` }
      }

      // 内容が異なる場合、ローカル優先でクラウドを更新
      const fileContent = generateMemoFileContent(
        localMemo.title,
        localMemo.content,
        localMemo.game.title
      )

      await uploadObject(s3Client, bucketName, s3Key, fileContent, "text/markdown")
      return {
        action: "cloudOverwritten",
        message: `クラウド更新: ${localMemo.title} (同じタイムスタンプ・内容異なる)`
      }
    }

    return { action: "skipped", message: `スキップ: ${localMemo.title} (クラウド内容取得失敗)` }
  }
}

/**
 * クラウドメモをローカルにダウンロードします
 */
export async function downloadCloudMemo(
  s3Client: S3Client,
  bucketName: string,
  cloudMemo: CloudMemoInfo,
  game: { id: string; title: string }
): Promise<{
  action: "created" | "localOverwritten" | "cloudOverwritten" | "skipped"
  message: string
}> {
  // メモ内容をダウンロード
  const content = await downloadCloudMemoContent(s3Client, bucketName, cloudMemo.key)

  if (!content) {
    return { action: "skipped", message: `内容が取得できないためスキップ: ${cloudMemo.memoTitle}` }
  }

  const actualContent = extractMemoContent(content)

  // 既存のメモを確認
  const existingMemo = await prisma.memo.findFirst({
    where: {
      gameId: game.id,
      title: cloudMemo.memoTitle
    }
  })

  if (!existingMemo) {
    // 新しいメモを作成
    const newMemo = await prisma.memo.create({
      data: {
        title: cloudMemo.memoTitle,
        content: actualContent,
        gameId: game.id
      }
    })

    // ローカルファイルを作成
    await memoFileManager.createMemoFile(game.id, newMemo.id, newMemo.title, actualContent)

    return { action: "created", message: `作成: ${cloudMemo.memoTitle}` }
  }

  // 既存メモの場合、タイムスタンプと内容を比較
  const localUpdatedAt = existingMemo.updatedAt
  const cloudLastModified = cloudMemo.lastModified

  const localContentHash = calculateContentHash(existingMemo.content)
  const cloudContentHash = calculateContentHash(actualContent)

  if (localContentHash === cloudContentHash) {
    return { action: "skipped", message: `スキップ: ${cloudMemo.memoTitle} (内容が同じ)` }
  }

  if (cloudLastModified > localUpdatedAt) {
    // クラウドの方が新しい場合、ローカルを更新
    await prisma.memo.update({
      where: { id: existingMemo.id },
      data: {
        content: actualContent,
        updatedAt: new Date()
      }
    })

    // ローカルファイルも更新
    await memoFileManager.updateMemoFile(
      game.id,
      existingMemo.id,
      existingMemo.title,
      cloudMemo.memoTitle,
      actualContent
    )

    return {
      action: "localOverwritten",
      message: `ローカル更新: ${cloudMemo.memoTitle} (クラウド版が新しい)`
    }
  } else if (localUpdatedAt > cloudLastModified) {
    // ローカルの方が新しい場合、クラウドを更新
    const s3Key = CloudPathManager.buildMemoPath(game.title, existingMemo.title, existingMemo.id)

    const fileContent = generateMemoFileContent(
      existingMemo.title,
      existingMemo.content,
      game.title
    )

    await uploadObject(s3Client, bucketName, s3Key, fileContent, "text/markdown")
    return {
      action: "cloudOverwritten",
      message: `クラウド更新: ${existingMemo.title} (ローカル版が新しい)`
    }
  } else {
    // タイムスタンプが同じ場合、クラウド優先で更新
    await prisma.memo.update({
      where: { id: existingMemo.id },
      data: {
        content: actualContent,
        updatedAt: new Date()
      }
    })

    // ローカルファイルも更新
    await memoFileManager.updateMemoFile(
      game.id,
      existingMemo.id,
      existingMemo.title,
      cloudMemo.memoTitle,
      actualContent
    )

    return {
      action: "localOverwritten",
      message: `ローカル更新: ${cloudMemo.memoTitle} (同じタイムスタンプ・内容異なる)`
    }
  }
}

/**
 * クラウドからメモ内容をダウンロードします
 */
async function downloadCloudMemoContent(
  s3Client: S3Client,
  bucketName: string,
  key: string
): Promise<string | null> {
  try {
    return await downloadObject(s3Client, bucketName, key)
  } catch (error) {
    logger.error(`クラウドメモダウンロードエラー: ${key}`, error)
    return null
  }
}

/**
 * メモ同期を実行します
 */
export async function syncMemos(
  s3Client: S3Client,
  bucketName: string,
  cloudMemos: CloudMemoInfo[],
  gameId?: string
): Promise<MemoSyncResult> {
  const syncResult: MemoSyncResult = {
    success: true,
    uploaded: 0,
    localOverwritten: 0,
    cloudOverwritten: 0,
    created: 0,
    updated: 0,
    skipped: 0,
    details: []
  }

  // 処理済みメモを追跡するためのSet（重複処理を防ぐため）
  const processedMemos = new Set<string>()

  try {
    // 1. ローカルメモをクラウドにアップロード
    const localMemos = await getLocalMemos(gameId)

    for (const localMemo of localMemos) {
      try {
        const sanitizedGameTitle = localMemo.game.title.replace(/[<>:"/\\|?*]/g, "_")
        const memoKey = `${sanitizedGameTitle}:${localMemo.id}`

        const existingCloudMemo = cloudMemos.find(
          (cloudMemo) =>
            cloudMemo.memoId === localMemo.id && cloudMemo.gameTitle === sanitizedGameTitle
        )

        const result = await uploadLocalMemo(s3Client, bucketName, localMemo, existingCloudMemo)

        switch (result.action) {
          case "uploaded":
            syncResult.uploaded++
            processedMemos.add(memoKey)
            break
          case "cloudOverwritten":
            syncResult.cloudOverwritten++
            processedMemos.add(memoKey)
            break
          case "skipped":
            if (!result.message.includes("ダウンロード処理待ち")) {
              syncResult.skipped++
              processedMemos.add(memoKey)
            }
            break
        }

        syncResult.details.push(result.message)
      } catch (error) {
        logger.error(`メモアップロードエラー: ${localMemo.title}`, error)
        syncResult.details.push(`アップロードエラー: ${localMemo.title} - ${error}`)
      }
    }

    // 2. クラウドメモをローカルにダウンロード
    for (const cloudMemo of cloudMemos) {
      try {
        // 既に処理済みかチェック
        const memoKey = `${cloudMemo.gameTitle}:${cloudMemo.memoId}`
        if (processedMemos.has(memoKey)) {
          continue
        }

        // ゲームを検索
        const game = await prisma.game.findFirst({
          where: {
            title: {
              contains: cloudMemo.gameTitle.replace(/_/g, " ")
            }
          }
        })

        if (!game) {
          syncResult.skipped++
          syncResult.details.push(
            `ゲーム「${cloudMemo.gameTitle}」が見つからないためスキップ: ${cloudMemo.memoTitle}`
          )
          continue
        }

        const result = await downloadCloudMemo(s3Client, bucketName, cloudMemo, game)

        switch (result.action) {
          case "created":
            syncResult.created++
            break
          case "localOverwritten":
            syncResult.localOverwritten++
            break
          case "cloudOverwritten":
            syncResult.cloudOverwritten++
            break
          case "skipped":
            syncResult.skipped++
            break
        }

        syncResult.details.push(result.message)
      } catch (error) {
        logger.error(`メモ同期エラー: ${cloudMemo.memoTitle}`, error)
        syncResult.details.push(`エラー: ${cloudMemo.memoTitle} - ${error}`)
      }
    }

    logger.info(
      `メモ同期完了: アップロード${syncResult.uploaded}件、作成${syncResult.created}件、ローカル上書き${syncResult.localOverwritten}件、クラウド上書き${syncResult.cloudOverwritten}件、スキップ${syncResult.skipped}件`
    )

    return syncResult
  } catch (error) {
    logger.error("メモ同期エラー:", error)
    return {
      success: false,
      uploaded: 0,
      localOverwritten: 0,
      cloudOverwritten: 0,
      created: 0,
      updated: 0,
      skipped: 0,
      error: "メモの同期に失敗しました",
      details: []
    }
  }
}

/**
 * ローカルメモを取得します
 */
async function getLocalMemos(gameId?: string): Promise<
  Array<{
    id: string
    title: string
    content: string
    game: { title: string }
  }>
> {
  if (gameId) {
    return await prisma.memo.findMany({
      where: { gameId },
      include: { game: { select: { title: true } } }
    })
  } else {
    return await prisma.memo.findMany({
      include: { game: { select: { title: true } } }
    })
  }
}
