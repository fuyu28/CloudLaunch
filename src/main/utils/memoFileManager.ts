/**
 * @fileoverview メモファイル管理ユーティリティ
 *
 * このファイルは、メモの.mdファイルの作成・保存・削除を管理します。
 * - ユーザーデータディレクトリにメモファイルを保存
 * - ゲームIDごとにディレクトリを作成
 * - ファイル名の安全化とバックアップ
 * - ファイル操作のエラーハンドリング
 */

import fs from "fs/promises"
import path from "path"
import { app } from "electron"
import { logger } from "./logger"

/**
 * メモファイル管理クラス
 */
export class MemoFileManager {
  private readonly baseDir: string

  constructor() {
    // ユーザーデータディレクトリにmemosフォルダを作成
    this.baseDir = path.join(app.getPath("userData"), "memos")
  }

  /**
   * ベースディレクトリを初期化
   */
  async initializeBaseDir(): Promise<void> {
    try {
      await fs.mkdir(this.baseDir, { recursive: true })
    } catch (error) {
      logger.error("メモベースディレクトリ作成エラー:", error)
      throw new Error("メモディレクトリの初期化に失敗しました")
    }
  }

  /**
   * ゲームIDからディレクトリパスを取得
   * @param gameId ゲームID
   * @returns ディレクトリパス
   */
  private getGameMemoDir(gameId: string): string {
    return path.join(this.baseDir, this.sanitizeFileName(gameId))
  }

  /**
   * メモファイルのフルパスを取得
   * @param gameId ゲームID
   * @param memoId メモID
   * @param title メモタイトル
   * @returns ファイルパス
   */
  private getMemoFilePath(gameId: string, memoId: string, title: string): string {
    const gameDir = this.getGameMemoDir(gameId)
    const fileName = `${this.sanitizeFileName(title)}_${memoId}.md`
    return path.join(gameDir, fileName)
  }

  /**
   * ファイル名を安全化
   * @param name ファイル名
   * @returns 安全化されたファイル名
   */
  private sanitizeFileName(name: string): string {
    // 危険な文字を置換
    return name
      .replace(/[<>:"/\\|?*]/g, "_")
      .replace(/\s+/g, "_")
      .substring(0, 100) // 長すぎるファイル名を制限
  }

  /**
   * メモファイルを作成
   * @param gameId ゲームID
   * @param memoId メモID
   * @param title メモタイトル
   * @param content メモ内容
   * @returns 作成されたファイルパス
   */
  async createMemoFile(
    gameId: string,
    memoId: string,
    title: string,
    content: string
  ): Promise<string> {
    try {
      // ゲームディレクトリを作成
      const gameDir = this.getGameMemoDir(gameId)
      await fs.mkdir(gameDir, { recursive: true })

      // ファイルパスを生成
      const filePath = this.getMemoFilePath(gameId, memoId, title)

      // メモファイルを作成
      const fileContent = this.generateMemoFileContent(title, content)
      await fs.writeFile(filePath, fileContent, "utf-8")

      logger.info(`メモファイルを作成しました: ${filePath}`)
      return filePath
    } catch (error) {
      logger.error("メモファイル作成エラー:", error)
      throw new Error("メモファイルの作成に失敗しました")
    }
  }

  /**
   * メモファイルを更新
   * @param gameId ゲームID
   * @param memoId メモID
   * @param oldTitle 旧タイトル
   * @param newTitle 新タイトル
   * @param content メモ内容
   * @returns 更新されたファイルパス
   */
  async updateMemoFile(
    gameId: string,
    memoId: string,
    oldTitle: string,
    newTitle: string,
    content: string
  ): Promise<string> {
    try {
      const oldFilePath = this.getMemoFilePath(gameId, memoId, oldTitle)
      const newFilePath = this.getMemoFilePath(gameId, memoId, newTitle)

      // 新しい内容でファイルを作成
      const fileContent = this.generateMemoFileContent(newTitle, content)
      await fs.writeFile(newFilePath, fileContent, "utf-8")

      // タイトルが変更された場合、古いファイルを削除
      if (oldTitle !== newTitle) {
        try {
          await fs.unlink(oldFilePath)
          logger.info(`旧メモファイルを削除しました: ${oldFilePath}`)
        } catch (unlinkError) {
          // 古いファイルの削除に失敗しても続行
          logger.warn("旧メモファイルの削除に失敗:", unlinkError)
        }
      }

      logger.info(`メモファイルを更新しました: ${newFilePath}`)
      return newFilePath
    } catch (error) {
      logger.error("メモファイル更新エラー:", error)
      throw new Error("メモファイルの更新に失敗しました")
    }
  }

  /**
   * メモファイルを削除
   * @param gameId ゲームID
   * @param memoId メモID
   * @param title メモタイトル
   */
  async deleteMemoFile(gameId: string, memoId: string, title: string): Promise<void> {
    try {
      const filePath = this.getMemoFilePath(gameId, memoId, title)
      await fs.unlink(filePath)
      logger.info(`メモファイルを削除しました: ${filePath}`)
    } catch (error) {
      logger.error("メモファイル削除エラー:", error)
      throw new Error("メモファイルの削除に失敗しました")
    }
  }

  /**
   * ゲームの全メモファイルを削除
   * @param gameId ゲームID
   */
  async deleteGameMemoFiles(gameId: string): Promise<void> {
    try {
      const gameDir = this.getGameMemoDir(gameId)
      await fs.rm(gameDir, { recursive: true, force: true })
      logger.info(`ゲームのメモディレクトリを削除しました: ${gameDir}`)
    } catch (error) {
      logger.error("ゲームメモディレクトリ削除エラー:", error)
      throw new Error("ゲームメモディレクトリの削除に失敗しました")
    }
  }

  /**
   * メモファイルの内容を生成
   * @param title メモタイトル
   * @param content メモ内容
   * @returns ファイル内容
   */
  private generateMemoFileContent(title: string, content: string): string {
    const timestamp = new Date().toISOString()
    return `# ${title}

<!-- Created: ${timestamp} -->
<!-- Generated by CloudLaunch -->

${content}
`
  }

  /**
   * メモファイルのパスを取得（読み取り専用）
   * @param gameId ゲームID
   * @param memoId メモID
   * @param title メモタイトル
   * @returns ファイルパス
   */
  getMemoFilePathForReading(gameId: string, memoId: string, title: string): string {
    return this.getMemoFilePath(gameId, memoId, title)
  }

  /**
   * ゲームのメモディレクトリパスを取得
   * @param gameId ゲームID
   * @returns ディレクトリパス
   */
  getGameMemoDirPath(gameId: string): string {
    return this.getGameMemoDir(gameId)
  }

  /**
   * ベースディレクトリパスを取得
   * @returns ベースディレクトリパス
   */
  getBaseDirPath(): string {
    return this.baseDir
  }

  /**
   * ベースディレクトリを取得
   * @returns ベースディレクトリパス
   */
  getBaseDir(): string {
    return this.baseDir
  }
}

// シングルトンインスタンス
export const memoFileManager = new MemoFileManager()
